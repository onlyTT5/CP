# （12）- 类型转换 | 今天你打卡了吗？

[toc]

## 一、概念

- **类型转换** 就是将数据（即 变量、数值、表达式 等的结果）从一种类型转换成另一种类型。
- 今天的章节主要围绕以下内容展开：

![20210629080032451](D:/GitRep/CP/notes/%EF%BC%8812%EF%BC%89-%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%20%20%E4%BB%8A%E5%A4%A9%E4%BD%A0%E6%89%93%E5%8D%A1%E4%BA%86%E5%90%97%EF%BC%9F.assets/20210629080032451.png)

## 二、类型转换

### 1、自动类型转换

- 自动类型转换就是编译器隐式地进行数据类型转换
- 这个过程不需要写代码的人干预，会自动发生。
- 自动类型转换主要发生在两个时机：赋值 和 运算。

---

1. #### 赋值

   - 将一种类型的数据赋值给另外一种类型的变量时会发生自动类型转换，如下代码所示：

   ```c
   #include <stdio.h>
   int main() {
       float love = 520;
       return 0;
   }
   ```

   - 这里的`520`原本是`int`类型的数据，为了赋值给`love`，他需要转换成`float`类型。
   - 再来看另一个例子：

   ```c
   #include <stdio.h>
   int main() {
       int loveyou = 11.0 / 9;
       return 0;
   }
   ```

   - `11.0 / 9`的值明显不是一个整数，但是它需要赋值给`int`，所以需要先转换为`int`类型以后，才能赋值给变量`loveyou`。
   - 由于在赋值运算中，赋值号两边的数据类型不同时，需要把右边数据的类型转换为左边变量的类型，这可能会导致数据失真，或者精度降低（例如上面例子中所说的浮点数转整数，就会截掉小数部分）。

2. #### 运算

   - 在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换的规则如下：

   ![20210629080729825](D:/GitRep/CP/notes/%EF%BC%8812%EF%BC%89-%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%20%20%E4%BB%8A%E5%A4%A9%E4%BD%A0%E6%89%93%E5%8D%A1%E4%BA%86%E5%90%97%EF%BC%9F.assets/20210629080729825.png)

   > 转换原则如下：
   >   1）数据长度短的向输出长度长的进行转换；
   >   2）精度低的向精度高的进行转换；

   - 注意，所有的浮点运算都是以双精度进行的，即使运算中只有`float`类型，也要先转换为`double`类型，才能进行运算。
   - 当`char`和`short`参与运算时，必须先转换成`int`类型。
   - 来看一个计算圆周长的例子：

   ```c
   #include <stdio.h>
   #include <math.h>
   const float PI = acos(-1.0);  // 3.1415926535...
   int main(){
       int c1, r = 10;
       double c2;
       c1 = 2 * PI * r;
       c2 = 2 * PI * r;
       printf("c1=%d, c2=%lf\n", c1, c2);
       return 0;
   }
   ```

   - 输出结果为：

   ```c
   c1=62, c2=62.831855
   ```

   - 上述例子中，`c1`是`int`类型，`c2`是`double`类型，赋值号右边的内容是计算圆的周长，完全相同，但是就是由于被赋值的变量类型不同，从而导致运算结果截然不同。
   - 虽然表达式的结果都是`double`类型。但由于`c1`为`int`类型，所以赋值运算的结果仍为`int`类型，舍去了小数部分，导致数据失真。

### 2、强制类型转换

- 自动类型转换是编译器根据代码的上下文环境自行判断的，有时候并不是那么智能，不能满足所有的需求。所以有时候需要写代码的人，也就是程序员能够自己在代码中明确地提出要进行类型转换，这就是强制类型转换。

1. #### 强制类型转换的格式

```c
(type_name) expression
```

- 其中 type_name 为新类型名称，expression为需要进行强制类型转换的表达式。

2. #### 64位整数强转

   - 让我们来看个非常容易犯错的例子：

   ```c
   #include <stdio.h>
   int main(){
       long long x = 1 << 32;
       printf("%lld\n", x); 
       return 0;
   }
   ```

   - 然而，这个程序的输出结果为：

   ```c
   0
   ```

   - 回想一下，我们 [光天化日学C语言（03）- 变量](D:/GitRep/CP/notes/（03）- 变量  万物皆变化，唯有初心不变.md) 这一节中学到的，整数的范围最大不会超过 2^32^-1，所以这里显然是超了。
   - 更加具体的原因，这里的`1`是`int`类型，所以进行左移`32`位时，产生了==溢出==，所以变成了`0`，这里涉及到补码相关的知识，我会在后续章节详细进行讲解。
   - 所以，我们需要先把 1 强制转换成`long long`再进行左移运算，如下：

   ```c
   #include <stdio.h>
   int main(){
       long long x = (long long)1 << 32;
       printf("%lld\n", x); 
       return 0;
   }
   ```

   - 得到的结果为：

   ```c
   4294967296
   ```

   - 是我们期望的结果，即2^32^。

3. #### 浮点数强转

   - 另一个比较经典的例子，就是我们计算除法的时候，如下：

   ```c
   #include <stdio.h>
   int main(){
       int a = 10;
       int b = 3; 
       double c = a / b;
       printf("%lf\n", c); 
       return 0;
   }
   ```

   - 得到的结果为：

   ```c
   3.000000
   ```

   - 原因是因为`a`和`b`都是`int`类型，如果不进行干预，那么`a / b`的运算结果也是`int`类型，小数部分将被丢弃；虽然是`c`是`double`类型，可以接收小数部分，但是在赋值之前，小数部分提前就被舍弃了，它只能接收到整数部分，这就导致除法运算的结果失真。
   - 修改方案如下：

   ```c
   #include <stdio.h>
   int main(){
       int a = 10;
       int b = 3; 
       double c = (double) a / b;
       printf("%lf\n", c); 
       return 0;
   }
   ```

   - 核心就是：不改变原有表达式的值，在其中添加一些`double`类型的数，使得整个表达式转换成`double`。
   - 使用强制类型转换时，有时候可能不是编译器想要的那样，因为这是写代码的人自己的行为，所以程序员自己要意识到其中潜在的风险。
   - 比如将指针转换成整型，或者将`double`转换成指针，当然，有些强制转换可能直接导致程序崩溃。