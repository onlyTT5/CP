# （14）- 位运算 & 的应用 | C语言课上学不到的哦~

[toc]

## 一、位与运算符

- 位与运算符是一个二元的位运算符，也就是有两个操作数，表示为`x & y`。
- 位与运算会对操作数的每一位按照如下表格进行运算，对于每一位只有 0 或 1 两种情况，所以组合出来总共2^2^=4种情况。

| 左操作数 | 右操作数 | 结果 |
| -------- | -------- | ---- |
| 0        | 0        | 0    |
| 0        | 1        | 0    |
| 1        | 0        | 0    |
| 1        | 1        | 1    |

- 通过这个表，我们得出一些结论：
  1. 无论是 0 或 1，只要位与上 1，还是它本身；
  2. 无论是 0 或 1，只要位与上 0，就变成 0；

> 只要出现0结果就为0

```c
#include <stdio.h>
int main() {
    int a = 0b1010;           // (1)
    int b = 0b0110;           // (2)
    printf("%d\n", (a & b) ); // (3)
    return 0;
}
```

1. 在C语言中，以`0b`作为前缀，表示这是一个二进制数。那么a的实际值就是(1010)~2~。
2. 同样的,`b`的实际值就是(0110)~2~;
3. 那么这里`a & b`就是对(1010)~2~和(0110)~2~的每一位做表格`&`运算。
4. 所以最后输出结果为

```c
2
```

- 因为输出的是十进制数，它的二进制表示为：(0010)~2~。
- 注意：这里的 **前导零** 可有可无，作者写上前导零只是为了对齐以及让读者更加清楚位与的运算方式。

## 二、位与运算符的应用

### 1、奇偶性判定

- 我们判断一个数是奇数还是偶数，往往是通过取模`%`来判断的，如下：

```c
#include <stdio.h>
int main() {
    if(5 % 2 == 1) {
        printf("5是奇数\n");
    }
    if(6 % 2 == 0) {
        printf("6是偶数\n");
    }
    return 0;
} 
```

- 然而，我们也可以这么写：

```c
#include <stdio.h>
int main() {
    if(5 & 1) {
        printf("5是奇数\n");
    }
    if( (6 & 1) == 0 ) {
        printf("6是偶数\n");
    }
    return 0;
} 
```

- 哇，好神奇！
- 这是利用了奇数和偶数分别的二进制数的特性，如下表所示：

| -    | 二进制末尾位 |
| ---- | ------------ |
| 奇数 | 1            |
| 偶数 | 0            |

- 所以，我们对任何一个数，通过将它和 `0b1`进行位与，结果为零，则必然这个数的二进制末尾位为0，根据以上表就能得出它是偶数了；否则，就是奇数。
- 注意，由于`if`语句我们还没有实际提到过，所以这里简单提一下，后面会有系统的讲解：

```c
	if( expr ) { body }
```

- 对于以上语句，`expr`代表的是一个表达式，表达式的值最后只有 零 或 非零，如果值为非零，才会执行`body`中的内容。

### 2、取末五位

> 【例题1】给定一个数，求它的二进制表示的末五位，以十进制输出即可。

- 这个问题的核心就是：我们只需要末五位，剩下的位我们是不需要的，所以可以将给定的数 位与上`0b11111`，这样一来就直接得到末五位的值了。
- 代码实现如下：

```c
#include <stdio.h>
int main() {
    int x;
    scanf("%d", &x);
    printf("%d\n", (x & 0b11111) );
    return 0;
} 
```

> 【例题2】如果是想得到末七位、末九位、末十四位、末 K 位，应该如何实现呢？

### 3、消除末尾五位

> 【例题3】给定一个32位整数，要求消除它的末5位。

- 还是根据位与的性质，消除末五位的含义，有两层：

  1. 末五位，要全变成零；
  2. 剩下的位不变；

- 那么，根据位运算的性质，我们需要数，它的高27位都为1，低五位都为 0，则这个数就是：

- $$
  (11111111111111111111111111100000)_2
  $$

- 但是如果要这么写，代码不疯掉，人也会疯掉，所以一般我们把它转成十六进制，每四个二进制位可以转成一个十六进制数，所以得到十六进制数为`0xffffffe0`。

- 代码实现如下：

```c
#include <stdio.h>
int main() {
    int x;
    scanf("%d", &x);
    printf("%d\n", (x & 0xffffffe0) );
    return 0;
} 
```

### 4、消除末尾连续1

> 【例题4】给出一个整数，现在要求将这个整数转换成二进制以后，将末尾连续的1都变成0，输出改变后的数（以十进制输出即可）。

- 我们知道，这个数的二进制表示形式一定是：

- $$
  k\left\{
  \begin{aligned}
  ...011...11
  \end{aligned}
  \right.
  $$

- 如果，我们把这个二进制数加上1，得到的就是：
  
- $$
  k\left\{
  \begin{aligned}
  ...100...00
  \end{aligned}
  \right.
  $$

- 我们把这两个数进行位与运算，得到：
  
- $$
  k\left\{
  \begin{aligned}
  ...000...00
  \end{aligned}
  \right.
  $$

```c
#include <stdio.h>
int main()
{
	int x;
	scanf_s("%d", &x);
	printf("%d\n", (x + 1) & x);
	return 0;
}
```

### 5、2的幂运算

> 【例题5】请用一句话，判断一个正数是不是2的幂。

- 如果一个数是 2 的幂，它的二进制表示必然为以下形式：

- $$
  k\left\{
  \begin{aligned}
  100...00
  \end{aligned}
  \right.
  $$

- 这个数的十进制值为2^k^。

- 那么我们将它减一，即2^k^-1的二进制表示如下（参考二进制减法的借位）：

- $$
  k\left\{
  \begin{aligned}
  011...11
  \end{aligned}
  \right.
  $$

- 于是 这两个数位与的结果为零，于是我们就知道了如果一个数 x 是 2 的幂，那么`x & (x-1)`必然为零。而其他情况则不然。

- 所以本题的答案为：

- ```c
  #include <stdio.h>
  int main()
  {
      int x;
      scanf_s("%d", &x);
      printf("%d", (x & (x - 1)) =);
      return 0；
  }
  ```
  
  