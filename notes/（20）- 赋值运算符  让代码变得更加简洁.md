# （20）- 赋值运算符 | 让代码变得更加简洁

[toc]

## 一、赋值运算概览

1. ### 赋值运算符

   - 今天我们来讲一下赋值运算符。
   - 对于赋值运算符，主要分为两类：==简单赋值运算符== 和 ==复合赋值运算符==。如下图所示：

   ![2021070808043845](D:/GitRep/CP/notes/%EF%BC%8820%EF%BC%89-%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%20%20%E8%AE%A9%E4%BB%A3%E7%A0%81%E5%8F%98%E5%BE%97%E6%9B%B4%E5%8A%A0%E7%AE%80%E6%B4%81.assets/2021070808043845.png)

   - 简单赋值运算符，我们之前在讲 [光天化日学C语言（03）- 变量] 的时候就已经遇到了，它的表示形式如下：

   - $$
     变量 = 常量\\
     变量 = 表达式
     $$

   - 即将赋值符号`=`右边的操作数的值赋值给左边的操作数。

2. ### 赋值表达式

   - 类似这样的表达式，我们称之为 **赋值表达式**。
   - 例如：

   ```c
   a = 10189;
   a = a + 5;
   ```

   - 任何表达式都是有值的，赋值表达式也不例外，它的值就是`=`右边的值。
   - 试想一下这段代码的输出是多少？

   ```c
   #include <stdio.h>
   int main() {
       int a = 5;
       int b = (a = 5); 
       printf("%d\n", b);
       return 0;
   } 
   ```

   - 运行结果为：

   ```c
   5
   ```

   - 原因就是因为表达式`a = 5`的值为`5`，从而等价于`b = 5`。

3. ### 赋值运算地自动类型转换

   - 赋值运算符会进行**自动类型转换**，转换类型就是左边操作数的类型。

   ```c
   #include <stdio.h>
   int main() {
       int a = 0;
       a = a + 1.5;
       printf("%d\n", a);
       return 0;
   } 
   ```

   - 输出的结果为：

   ```c
   1
   ```

   - 有关类型转换的内容，可以参考[光天化日学C语言（12）- 类型转换](D:/GitRep/CP/notes/（12）- 类型转换  今天你打卡了吗？.md)。

4. ### 连续赋值

   - 我们来看一个例子，如下：

   ```c
   #include <stdio.h>
   int main() {
       int a, b, c, d = 0;
       a = b = c = d = d == 0;
       printf("%d\n", a);
       return 0;
   } 
   ```

   - 这段代码的运行结果为：

   ```c
   1
   ```

   - 为什么呢？
   - 它其实等价于：

   ```c
   #include <stdio.h>
   int main() {
       int a, b, c, d = 0;
       a = ( b = (c = ( d = (d == 0) ) ) );
       printf("%d\n", a);
       return 0;
   } 
   ```

   - 这里涉及到两个概念：==运算符优先级==、==运算符结合性==。
   - 具体的内容，我们会在后续内容中详细讲解。现在你只需要知道 赋值运算符`=`的优先级低于关系运算符`==`，所以`d = d == 0`等价于`d = (d == 0)`；而赋值运算符`=`的结合性是从右到左，所以`a = b = c`等价于`a = (b = c)`。

## 二、复合赋值运算符

- 首先来看一个赋值语句，如下：

```c
    int love;
    love = love + 1314;
```

- 像这种**表达式左边的变量**重复出现在**表达式的右边**，则可以缩写成：

```c
int love;
love += 1314
```

- 而这里的`+=`就是复合赋值运算符，类似的复合赋值运算符还有很多，总共分为两大类：算术赋值运算符、位赋值运算符。

- 1. ### 算术复合运算符

     - 算术运算符我们之前已经了解过了，具体可以参考这篇文章：[光天化日学C语言（09）- 算术运算符](D:/GitRep/CP/notes/（09）- 算术运算符  小学就会了？温故而知新，可以为师矣！.md)。
     - 而算术赋值运算符就是先进行算术运算，再进行赋值。算术赋值运算符的表格如下：

     | 运算符 | 简称             | 描述                                                         | 举例                      |
     | ------ | ---------------- | ------------------------------------------------------------ | ------------------------- |
     | `+=`   | 加且赋值运算符   | 将 **右边操作数** 加上 **左边操作数** 的结果赋值给 **左边操作数** | `a += b`等价于`a = a + b` |
     | `-=`   | 减且赋值运算符   | 将 **左边操作数** 减去 **右边操作数** 的结果赋值给 **左边操作数** | `a -= b`等价于`a = a - b` |
     | `*=`   | 乘且赋值运算符   | 将 **右边操作数** 乘以 **左边操作数** 的结果赋值给 **左边操作数** | `a *= b`等价于`a = a * b` |
     | `/=`   | 除且赋值运算符   | 将 **左边操作数** 除以 **右边操作数** 的结果赋值给 **左边操作数** | `a /= b`等价于`a = a / b` |
     | `%=`   | 求模且赋值运算符 | 求 **两个操作数的模**，并将结果赋值给 **左边操作数**         | a %= b`等价于`a = a % b   |

  2. ### 位赋值运算符

     - 位运算符我们之前已经了解过了，具体可以参考这篇文章：[光天化日学C语言（13）- 位运算概览](D:/GitRep/CP/notes/（13）- 位运算概览  开启位运算的征程.md)。
     - 而位赋值运算符就是先进行位运算，再进行赋值。位赋值运算符的表格如下：

     | 运算符 | 简称                 | 描述                                                         | 举例                        |
     | ------ | -------------------- | ------------------------------------------------------------ | --------------------------- |
     | `&=`   | 按位与且赋值运算符   | 将 **左边操作数** 按位与上 **右边操作数** 的结果赋值给 **左边操作数** | `a &= b`等同于`a = a & b`   |
     | `|=`   | 按位或且赋值运算符   | 将 **左边操作数** 按位或上 **右边操作数** 的结果赋值给 **左边操作数** | `a |= b`等同于`a = a | b`   |
     | `^=`   | 按位异或且赋值运算符 | 将 **左边操作数** 按位异或上 **右边操作数** 的结果赋值给 **左边操作数** | `a ^= b`等同于`a = a ^ b`   |
     | `<<=`  | 左移且赋值运算符     | 将 **左边操作数** 左移 **右边操作数** 的位数后的结果赋值给 **左边操作数** | `a <<= b`等同于`a = a << b` |
     | `>>=`  | 右移且赋值运算符     | 将 **左边操作数** 右移 **右边操作数** 的位数后的结果赋值给 **左边操作数** | a >>= b`等同于`a = a >> b   |

## 三、复合赋值表达式

- 对于两个表达式 e~1~ 和 e~2~，有复合赋值表达式：

- $$
  e_{1\ op} = e_2
  $$

- 等价于：

- $$
  e_1=(e_1)_{op}(e_2)
  $$

> 这样写的好处有三个：
>   1）前一种形式，e~1~ 只计算一次；第二种形式要计算两次。
>   2）前一种形式，不需要加上圆括号；第二种形式的圆括号不可少。
>   3）看起来简洁清晰；

- 举个极端的例子：

- `a.b.c.d.e.f[ 1024 + g.h.i.j.k.l ] = a.b.c.d.e.f[ 1024 + g.h.i.j.k.l ] + 5`

  炸裂的！！！

- 利用复合赋值表达式，我们就可以写成：`a.b.c.d.e.f[ 1024 + g.h.i.j.k.l ] += 5`（当然，这个例子比较极端，实际编码中千万不要写出这样的代码哦）。

