# （15）- 位运算 | 的应用

[toc]

## 一、位或运算符

- 位或运算符是一个二元的位运算符，也就是有两个操作数，表示为`x | y`。
- 位或运算会对操作数的每一位按照如下表格进行运算，对于每一位只有 0 或 1 两种情况，所以组合出来总共 2^2^=4种情况。
| 左操作数 | 右操作数 | 结果 |
| -------- | -------- | ---- |
| 0        | 0        | 0    |
| 0        | 1        | 1    |
| 1        | 0        | 1    |
| 1        | 1        | 1    |
- 通过这个表，我们得出一些结论：
  1. 无论是 0 或 1，只要位或上 1，就变成1；
  2. 只有当两个操作数都是0的时候，才变成 0；

> 位或运算的特点是：只要出现一，结果就为一。

```c
#include <stdio.h>
int main() {
    int a = 0b1010;           // (1)
    int b = 0b0110;           // (2)
    printf("%d\n", (a | b) ); // (3)
    return 0;
}
```

1. 在C语言中，以`0b`作为前缀，表示这是一个二进制数。那么a的实际值就是(1010)~2~。
2. 同样的,`b`的实际值就是(0110)~2~。
3. 那么这里`a & b`就是对(1010)~2~和(0110)~2~的每一位做表格`|`运算。
4. 所以最后输出结果为：

```c
14
```

- 因为输出的是十进制数，它的二进制表示为：(1110)~2~。

## 二、位或运算符的应用



1. ### 设置标记位

   > 【例题1】给定一个数，判断它二进制低位的第 5 位，如果为 0，则将它置为 1。

   - 这个问题，我们很容易联想到位或。
   - 我们分析一下题目意思，如果第 5 位为 1，不用进行任何操作；如果第 5 位为 0，则置为 1。言下之意，无论第五位是什么，我们都直接置为 1即可，代码如下：

   ```c
   #include <stdio.h>
   int main()
   {
       int x;
       scanf_s("%d", &x);
       printf("%d", x & 0b10000);
       return 0;
   }    
   ```

2. ### 置空标记位

   > 【例题2】给定一个数，判断它二进制低位的第 5 位，如果为 1，则将它置为 0。

   - 这个问题，我们在学过==光天化日学C语言（14）- 位运算 & 的应用==以后，很容易得出这样一种做法：

   ```c
   #include <stdio.h>
   int main() {
       int x;
       scanf("%d", &x);
       printf("%d\n", x & 0b11111111111111111111111111101111); 
       return 0;
   }
   ```

   - 其它位不能变，所以位与上1；第5位要置零，所以位与上0；
   - 这样写有个问题，就是这串数字太长了，一点都不美观，而且容易写错，当然我们也可以转换成 十六进制，转换的过程也有可能出错。
   - 而我们利用位或，只能将第5位设置成1，怎么把它设置成0呢？

   > 我们可以配合减法来用。分成以下两步：
   >
   > 1. 首先，强行将低位的第5位置成1；
   > 2. 然后，强行将低位的第5位去掉；

   - 第（1）步可以采用位或运算，而第（2）步，我们可以直接用减法即可。
   - 代码实现如下：

   ```c
   #include <stdio.h>
   int main() {
       int x;
       int a = 0b10000; 
       scanf("%d", &x);
       printf("%d\n", (x | a) - a ); 
       return 0;
   }
   ```

   - 注意：直接减是不行的，因为我们首先要保证那一位为 1，否则贸然减会产生借位，和题意不符。

3. ### 低位连续零变一

   > 【例题3】给定一个整数 x ，将它低位连续的 0 都变成 1。

   - 假设这个整数低位连续有 k 个零，二进制表示如下：

   - $$
     k\left\{
     \begin{aligned}
     ...100...00
     \end{aligned}
     \right.
     $$

   - 那么，如果我们对它进行减一操作，得到的二进制数就是：

   - $$
     k\left\{
     \begin{aligned}
     ...011...11
     \end{aligned}
     \right.
     $$

   - 我们发现，只要对这两个数进行位或，就能得到：

   - $$
     k\left\{
     \begin{aligned}
     ...111...11
     \end{aligned}
     \right.
     $$

   - 也正是题目所求，所以代码实现如下：

   ```c
   #include <stdio.h>
   int main() {
       int x;
       scanf("%d", &x);
       printf("%d\n", x | (x-1) );    // (1)
       return 0;
   }
   ```

4. ### 低位首零变一

   > 【例题4】给定一个整数 x x*x*，将它低位第一个 0 变成 1。

   ```c
   #include <stdio.h>
   int main() {
       int x;
       scanf("%d", &x);
       printf("%d\n", x | (x+1) );    // (1)
       return 0;
   }
   ```

   
