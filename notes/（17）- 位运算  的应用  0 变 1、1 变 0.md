# （17）- 位运算 ~ 的应用 | 0 变 1、1 变 0

[toc]

## 一、取反运算符

- 取反运算符是一个单目位运算符，也就是只有一个操作数，表示为`~x`。

- 取反运算会对操作数的每一位按照如下表格进行运算，对于每一位只有 0 或 1 两种情况。

| 操作数 | 取反结果 |
| ------ | -------- |
| 0      | 1        |
| 1      | 0        |

```c
#include <stdio.h>
int main() {
    int a = 0b1;
    printf("%d\n", ~a );
    return 0;
}
```

- 这里`~a`代表的是对二进制数 1 进行取反，直观感受应该是 0。

- 但是实际输出的却是：

```c
-2
```

- 这是为什么呢？
- 那是因为，这是一个 32 位整数，实际的取反操作是这样的：

```c
 ~ 00000000 00000000 00000000 00000001
 --------------------------------------
   11111111 11111111 11111111 11111110

```

- 32位整数的二进制表示，前导零也要参与取反。
- 而对于一个有符号的 32 位整数，我们需要用最高位来代表符号位，即最高位为 0，则代表正数；最高位为 1，则代表负数；
- 这时候我们就需要引入补码的概念了。

1. ### 补码

   - 在计算机中，二进制编码是采用补码的形式表示的，补码定义如下：

   > 正数的补码是它本身，符号位为 0；负数的补码为正数数值二进制位取反后加一，符号位为一；

2. ### 补码举例

   - 根据补码的定义，`-2`的补码计算，需要经过两步：

   - 1. 对 2 的二进制进行按位取反，如下：

     ```c
      ~ 00000000 00000000 00000000 00000010
      --------------------------------------
        11111111 11111111 11111111 11111101
     ```

     2. 然后加上 1，如下：

     ```c
        11111111 11111111 11111111 11111101
      + 00000000 00000000 00000000 00000001
      --------------------------------------
        11111111 11111111 11111111 11111110
     ```

3. ### 补码的真实含义

   - 补码的真实含义，其实体现在 “补” 这个字上，在数学上，两个互为相反数的数字相加等于 0，而在计算机中，两个互为相反数的数字相加等于2^n^。

   - 换言之，互为相反数的两个数互补，补成2^n^。

   - 对于32位整数，n=32；对于64位整型，n=64。所以补码也可以表示成如下形式：

   - $$
     [x]_补=\begin{cases}
     x &(0≤x<2^{n-1}) \\
     2^n+x &(-2^{n-1}≤x<0) \\
     \end{cases}
     $$

   - 于是，对于`int`类型，就有：
   
   - $$
     x+(-x)=2^{32}
     $$
   
   - 因此，-2=2^32^-2。
   
   - 于是，我们开始数数……
   
   ```c
   2^32        = 1 00000000 00000000 00000000 00000000
   2^32 - 1    =   11111111 11111111 11111111 11111111
   2^32 - 2    =   11111111 11111111 11111111 11111110
   ...
   ```
   
   - 近一步了解了`-2`的二进制表示。

## 二、取反运算符

1. ### 0的取反

> 【例题1】0 的取反结果为多少呢？

- 首先对源码进行取反，得到：

```c
 ~ 00000000 00000000 00000000 00000000
 --------------------------------------
   11111111 11111111 11111111 11111111
```

- 这个问题，我们刚讨论完，这个答案为2^32^-1。但是实际输出时，你会发现，它的值是`-1`。

- 这是为什么？

- 搞得我一头雾水。

- 原因是因为在C语言中有两种类型的`int`，分别为`unsigned int`和`signed int`，我们之前讨论的`int`都是`signed int`的简称。

- 1. #### 有符号整型

  - 对于有符号整型`signed int`而言，最高位表示符号位，所以只有31位能表示数值，能够表示的数值范围是:

  - $$
    -2^{31}≤x≤2^{31}-1
    $$

  - 所以，对于有符号整型，输出采用`%d`，如下：

  ```c
  #include <stdio.h>
  int main() {
      printf("%d\n", ~0 );
      return 0;
  }
  ```

  - 结果为：

  ```c
  -1
  ```

- 2. #### 无符号整型

  - 对于无符号整型`unsigned int`而言，由于不需要符号位，所以总共有32位表示数值，数值范围为：

  - $$
    0≤x≤2^{31}-1
    $$

  - 对于无符号整型，输出采用`%u`，如下：

  ```c
  #include <stdio.h>
  int main() {
      printf("%u\n", ~0 );
      return 0;
  }
  ```

  - 结果为

  ```c
  4294967295
  ```

  2. ### 相反数

  > 【例题2】给定一个int类型的正数 x ，求 x 的相反数（注意：不能用负号）。

  - 这里，我们可以直接利用补码的定义，对于正数 x ，它的相反数的补码就是 x 二进制取反加一。即：~x + 1。

  ```c
  #include <stdio.h>
  int main()
  {
   	int x = 18;
      printf("%d\n", ~x + 1);
      return 0;
  }
  ```
  
  - 运行结果如下：
  
  ```c
  18
  ```
  
  3. ### 代替减法
  
  > 【例题3】给定两个int类型的正数 x 和 y ，实现 x − y（注意：不能用减号）。
  
  - 这个问题比较简单，如果上面的相反数已经理解了，那么，`x - y`其实就可以表示成`x + (-y)`，而`-y`又可以表示成`~y + 1`，所以减法 `x - y`就可以用`x + ~y + 1`来代替。
  
  ```c
  #include <stdio.h>
  int main() {
      int a = 8;
      int b = 17; 
      printf("%d\n", a + ~b + 1 );
      return 0;
  }
  ```
  
  - 运行结果为：
  
  ```c
  -9
  ```
  
  4. ### 代替加法
  
  > 【例题4】给定两个int类型的正数 x 和 y ，实现 x + y（注意：不能用加号）。
  
  - 我们可以把`x + y`变成`x - (-y)`，而`-y`又可以替换成 `~y + 1`；
  - 所以`x + y`就变成了`x - ~y - 1`，不用加号实现了加法运算。
  
  ```c
  #include <stdio.h>
  int main() {
      int x = 18;
      int y = 7; 
      printf("%d\n", x - ~y - 1 );
      return 0;
  }
  ```
  
  - 运行结果为：
  
  ```c
  25
  ```
  
  
